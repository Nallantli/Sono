# Benjamin Park
# 29-06-2020

load "feature";
load "vector";
load "string";
load "map";
load "rule";

static Phonology class {
	getNaturalSet(ref phones, ref set) => {
		var m = [];
		p in set do {
			m += mat p;
		}
		return m from phones;
	}

	isNaturalSet(ref phones, ref set) => {
		var ns = getNaturalSet(phones, set);
		return len ns == len set;
	}

	findNaturalSets(ref phones, ref set, ref explored) => {
		explored == null then {
			explored = {};
		}
		explored += { set };
		var ns = {};
		isNaturalSet(phones, set) then {
			ns += { set };
		}
		len set > 2 then {
			i in {0 until len set} do {
				var nv = set;
				nv.remove(i);
				explored.contains(nv) == false then {
					var s = findNaturalSets(phones, nv, explored);
					len s > 0 then {
						ns += s;
					}
				}
			}
		}
		return ns;
	}

	naturalize(ref phones, ref set) => {
		var natural = (ref phones, ref matrix) => {
			var list = {};
			i in {0 until len matrix} do {
				var temp = mat (vec matrix).remove(i);
				(temp from phones) == (matrix from phones) then {
					list += natural(phones, temp);
					break;
				}
			}
			len list == 0 then {
				return { matrix };
			} else {
				return list;
			}
		}
		return natural(phones, com getNaturalSet(phones, set))[0];
	}
}

struct Corpus class {
	var corpus;
	var TFcache;
	var IDFcache;

	init() => {
		corpus = {};
		TFcache = new Map();
		IDFcache = new Map();
	}

	resetCache() => {
		TFcache = new Map();
		IDFcache = new Map();
	}

	add(value) => {
		type value != "Vector" then {
			value = value.split("\\s");
		}
		corpus += {value};
		resetCache();
	}

	TF(final value, final doc) => {
		TFcache.contains({value, doc}) then {
			return TFcache[{value, doc}];
		}
		var c = 0;
		doc == null then {
			i in corpus do {
				j in i do {
					j == value then {
						c += 1;
					}
				}
			}
		} else {
			j in corpus[doc] do {
				j == value then {
					c += 1;
				}
			}
		}
		return c;
	}

	count(ref value) => {
		var c = 0;
		i in corpus do {
			j in i do {
				j == value then {
					c += 1;
					break;
				}
			}
		}
		return c;
	}

	IDF(ref value) => {
		IDFcache.contains(value) then {
			return IDFcache[value];
		}
		return 1 + (len corpus / (1 + count(value))).log();
	}

	TFIDF(final value, final doc) => {
		var array = value;
		type value != "Vector" then {
			array = { value };
		}
		var freq = 0;
		v in array do {
			freq += TF(v, doc) * IDF(v);
		}
		return freq;
	}

	getList() => {
		return corpus;
	}

	getLen() => {
		return len corpus;
	}
}

struct Inventory class {
	var name;
	var phonemes;
	var rules;

	init(final name) => {
		this.name = name;
		this.phonemes = {};
		this.rules = {};
	}

	addPhoneme(phoneme) => {
		type phoneme != "Phone" then {
			throw "Cannot insert non-Phone value.";
		}
		phonemes.contains(phoneme) == false then {
			this.phonemes += { phoneme };
		}
	}

	addRule(rule) => {
		type phoneme != "Rule" then {
			throw "Cannot insert non-Rule value.";
		}
		rules.contains(rule) == false then {
			this.rules += { rule };
		}
	}

	transform(final words) => {
		return words.apply(rules);
	}

	getSet(ref matrix) => {
		return matrix from phonemes;
	}

	getNaturalSet(ref phones) => {
		return Phonology.getNaturalSet(this.phonemes, phones);
	}

	isNaturalSet(ref phones) => {
		return Phonology.isNaturalSet(this.phonemes, phones);
	}

	getStr() => {
		return this.name;
	}
}