load "hash";

struct Map class {
	struct Node class {
		var key;
		var value;
		var prev;
		var next;
		init(ref key, ref value, ref prev) => {
			this.key = key;
			this.value = value;
			this.prev = prev;
		};
		getStr() => {
			return str key + "=" + str value + str { next };
		};
	};

	var buckets;
	var size;
	var rawSize;

	init(ref rawSize) => {
		this.size = 0;
		rawSize == null then {
			this.rawSize = 16;
		} else {
			this.rawSize = rawSize;
		};
		this.buckets = alloc this.rawSize;
	};

	isEmpty() => {
		return (size == 0);
	};

	getIndex(ref key) => {
		size >= rawSize then {
			expand();
		};
		var h = hash(str key, rawSize);
		var curr = buckets[h];
		curr == null then {
			buckets[h] = new Node(key, null, null);
			size += 1;
			return buckets[h].value;
		};
		true do {
			curr.key == key then {
				return curr.value;
			};
			curr.next == null then {
				break;
			};
			curr = curr.next;
		};
		var p = new Node(key, null, curr);
		curr.next = p;
		size += 1;
		return p.value;
	};

	remove(ref key) => {
		var h = hash(str key, rawSize);
		var curr = buckets[h];
		true do {
			curr.key == key then {
				break;
			};
			curr.next == null then {
				return false;
			};
			curr = curr.next;
		};
		curr.prev == null then {
			buckets[h] = curr.next;
		} else {
			curr.prev.next = curr.next;
		};
		size -= 1;
		return true;
	};

	containsKey(ref key) => {
		var h = hash(str key, rawSize);
		var curr = buckets[h];
		curr != null do {
			curr.key == key then {
				return true;
			};
			curr = curr.next;
		};
		return false;
	};

	expand() => {
		size = 0;
		var vector = getList();
		rawSize = rawSize * 2;
		buckets = alloc rawSize;
		e in vector do {
			getIndex(e[0]) = e[1];
		};
	};

	getList() => {
		var list = {};
		b in buckets do {
			var curr = b;
			curr != null do {
				list += {{curr.key, curr.value}};
				curr = curr.next;
			};
		};
		return list;
	};

	getLen() => {
		return size;
	};

	getStr() => {
		return str getList();
	};
};