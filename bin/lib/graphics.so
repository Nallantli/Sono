import "LIB_Graphics";

struct Window class {
	var width;
	var height;
	var window;
	var graphics;

	init(&title, &width, &height, &closefunction) => {
		this.width = width;
		this.height = height;
		this.window = ("LIB_Graphics.INIT" _OUTER_CALL_ {title, width, height, closefunction});
	};

	show() => {
		"LIB_Graphics.SHOW" _OUTER_CALL_ (this.window);
	};

	hide() => {
		"LIB_Graphics.HIDE" _OUTER_CALL_ (this.window);
	};

	resize(&width, &height) => {
		"LIB_Graphics.SETSIZE" _OUTER_CALL_ {window, width, height};
		this.width = width;
		this.height = height;
	};

	close() => {
		"LIB_Graphics.CLOSE" _OUTER_CALL_ (this.window);
		this.window = null;
	};

	getGraphics() => {
		this.graphics == null then {
			this.graphics = new Graphics("LIB_Graphics.GETGRAPHICS" _OUTER_CALL_ (this.window));
		};
		return this.graphics;
	};

	repaint() => {
		"LIB_Graphics.REPAINT" _OUTER_CALL_ (this.window);
	};

	struct Graphics class {
		var graphics;

		init(&graphics) => {
			this.graphics = graphics;
		};

		add(&shape) => {
			var success = ("LIB_Graphics.GRAPHICS.ADD" _OUTER_CALL_ {this.graphics, shape.data});
			success == false then {
				throw "Shape already exists in Graphics";
			};
		};

		remove(&shape) => {
			"LIB_Graphics.GRAPHICS.REMOVE" _OUTER_CALL_ {this.graphics, shape.data};
			success == false then {
				throw "Shape does not exist in Graphics";
			};
		};
	};
};

static Shape class {
	struct Rectangle class {
		var data;

		var color;
		var x;
		var y;
		var width;
		var height;

		init(&color, &x, &y, &width, &height) => {
			this.color = color;
			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;
			this.data = ("LIB_Graphics.SHAPE.RECTANGLE.INIT" _OUTER_CALL_ {color.r, color.g, color.b, color.a, x, y, width, height});
		};

		setColor(&color) => {
			this.color = color;
			"LIB_Graphics.SHAPE.SETCOLOR" _OUTER_CALL_ {this.data, color.r, color.g, color.b, color.a};
		};

		setSize(&width, &height) => {
			this.width = width;
			this.height = height;
			"LIB_Graphics.SHAPE.RECTANGLE.SIZE" _OUTER_CALL_ {this.data, width, height};
		};

		setOrigin(&x, &y) => {
			this.x = x;
			this.y = y;
			"LIB_Graphics.SHAPE.RECTANGLE.MOVE" _OUTER_CALL_ {this.data, x, y};
		};

		move(&x, &y) => {
			this.x += x;
			this.y += y;
			"LIB_Graphics.SHAPE.RECTANGLE.MOVE" _OUTER_CALL_ {this.data, this.x, this.y};
		};
	};

	struct Oval class {
		var data;

		var color;
		var x;
		var y;
		var width;
		var height;

		init(&color, &x, &y, &width, &height) => {
			this.color = color;
			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;
			this.data = ("LIB_Graphics.SHAPE.OVAL.INIT" _OUTER_CALL_ {color.r, color.g, color.b, color.a, x, y, width, height});
		};

		setColor(&color) => {
			this.color = color;
			"LIB_Graphics.SHAPE.SETCOLOR" _OUTER_CALL_ {this.data, color.r, color.g, color.b, color.a};
		};

		setSize(&width, &height) => {
			this.width = width;
			this.height = height;
			"LIB_Graphics.SHAPE.OVAL.SIZE" _OUTER_CALL_ {this.data, width, height};
		};

		setOrigin(&x, &y) => {
			this.x = x;
			this.y = y;
			"LIB_Graphics.SHAPE.OVAL.MOVE" _OUTER_CALL_ {this.data, x, y};
		};

		move(&x, &y) => {
			this.x += x;
			this.y += y;
			"LIB_Graphics.SHAPE.OVAL.MOVE" _OUTER_CALL_ {this.data, this.x, this.y};
		};
	};

	struct Line class {
		var data;

		var color;
		var x1;
		var y1;
		var x2;
		var y2;

		init(&color, &x1, &y1, &x2, &y2) => {
			this.color = color;
			this.x1 = x1;
			this.y1 = y1;
			this.x2 = x2;
			this.y2 = y2;
			this.data = ("LIB_Graphics.SHAPE.LINE.INIT" _OUTER_CALL_ {color.r, color.g, color.b, color.a, x1, y1, x2, y2});
		};

		setColor(&color) => {
			this.color = color;
			"LIB_Graphics.SHAPE.SETCOLOR" _OUTER_CALL_ {this.data, color.r, color.g, color.b, color.a};
		};

		setPoints(&x1, &y1, &x2, &y2) => {
			this.x1 = x1;
			this.y1 = y1;
			this.x2 = x2;
			this.y2 = y2;
			"LIB_Graphics.SHAPE.LINE.MOVE" _OUTER_CALL_ {this.data, x1, y1, x2, y2};
		};

		move(&x, &y) => {
			this.x1 += x;
			this.x2 += x;
			this.y1 += y;
			this.y2 += y;
			"LIB_Graphics.SHAPE.LINE.MOVE" _OUTER_CALL_ {this.data, this.x1, this.y1, this.x2, this.y2};
		};
	};
};

static Color class {
	struct RGB class {
		var r;
		var g;
		var b;
		var a;

		init(&r, &g, &b, &a) => {
			this.r = r;
			this.g = g;
			this.b = b;
			a == null then {
				this.a = 255;
			} else {
				this.a = a;
			};
		};

		getStr() => {
			return "(" + str r + ", " + str g + ", " + str b + ", " + str a + ")";
		};
	};

	HSLtoRGB(&h, &s, &l, &a) => {
		var hueToRgb = (&p, &q, t) => {
			t < 0 then {
				t += 1;
			} else t > 1 then {
				t -= 1;
			};
			t < 1/6 then {
				return p + (q - p) * 6 * t;
			};
			t < 1/2 then {
				return q;
			};
			t < 2/3 then {
				return p + (q - p) * (2/3 - t) * 6;
			};
			return p;
		};
		var r;
		var g;
		var b;
		s == 0 then {
			r = l;
			g = l;
			b = l;
		} else {
			var q = (l < 0.5 then (l * (1 + s)) else (l + s - l * s));
			var p = 2 * l - q;
			r = hueToRgb(p, q, h + 1/3);
			g = hueToRgb(p, q, h);
			b = hueToRgb(p, q, h - 1/3);
		};
		r *= 256;
		g *= 256;
		b *= 256;
		r > 255 then { r = 255 };
		g > 255 then { g = 255 };
		b > 255 then { b = 255 };
		return new RGB(r, g, b, a);
	};

	var RED = new RGB(255, 0, 0, 255);
	var GREEN = new RGB(0, 255, 0, 255);
	var BLUE = new RGB(0, 0, 255, 255);
	var BLACK = new RGB(0, 0, 0, 255);
	var WHITE = new RGB(255, 255, 255, 255);
};