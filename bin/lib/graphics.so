# Benjamin Park
# 30-06-2020

import "LIB_Graphics";

struct Window class {
	var width;
	var height;
	var window;
	var graphics;

	init(final title, final width, final height, ref closefunction) => {
		this.width = width;
		this.height = height;
		this.window = ("LIB_Graphics.INIT" _OUTER_CALL_ (title, width, height, closefunction));
	}

	show() => {
		"LIB_Graphics.SHOW" _OUTER_CALL_ (this.window);
	}

	hide() => {
		"LIB_Graphics.HIDE" _OUTER_CALL_ (this.window);
	}

	resize(final width, final height) => {
		"LIB_Graphics.SETSIZE" _OUTER_CALL_ (window, width, height);
		this.width = width;
		this.height = height;
	}

	close() => {
		"LIB_Graphics.CLOSE" _OUTER_CALL_ (this.window);
		this.window = null;
	}

	getGraphics() => {
		this.graphics == null then {
			this.graphics = new Graphics("LIB_Graphics.GETGRAPHICS" _OUTER_CALL_ (this.window));
		}
		return this.graphics;
	}

	repaint() => {
		"LIB_Graphics.REPAINT" _OUTER_CALL_ (window);
	}

	onMouseMove(ref function) => {
		var mousef = (a, b, c, d, e, f, g) => {
			return function(new MouseEvent(a, b, c, d, e, f, g));
		}
		"LIB_Graphics.ADDMOUSELISTENER" _OUTER_CALL_ (window, 0, mousef);
	}

	onMouseDrag(ref function) => {
		var mousef = (a, b, c, d, e, f, g) => {
			return function(new MouseEvent(a, b, c, d, e, f, g));
		}
		"LIB_Graphics.ADDMOUSELISTENER" _OUTER_CALL_ (window, 1, mousef);
	}

	onMouseRelease(ref function) => {
		var mousef = (a, b, c, d, e, f, g) => {
			return function(new MouseEvent(a, b, c, d, e, f, g));
		}
		"LIB_Graphics.ADDMOUSELISTENER" _OUTER_CALL_ (window, 2, mousef);
	}

	onMousePress(ref function) => {
		var mousef = (a, b, c, d, e, f, g) => {
			return function(new MouseEvent(a, b, c, d, e, f, g));
		}
		"LIB_Graphics.ADDMOUSELISTENER" _OUTER_CALL_ (window, 3, mousef);
	}

	onMouseExit(ref function) => {
		var mousef = (a, b, c, d, e, f, g) => {
			return function(new MouseEvent(a, b, c, d, e, f, g));
		}
		"LIB_Graphics.ADDMOUSELISTENER" _OUTER_CALL_ (window, 4, mousef);
	}

	onMouseEnter(ref function) => {
		var mousef = (a, b, c, d, e, f, g) => {
			return function(new MouseEvent(a, b, c, d, e, f, g));
		}
		"LIB_Graphics.ADDMOUSELISTENER" _OUTER_CALL_ (window, 5, mousef);
	}

	onMouseClick(ref function) => {
		var mousef = (a, b, c, d, e, f, g) => {
			return function(new MouseEvent(a, b, c, d, e, f, g));
		}
		"LIB_Graphics.ADDMOUSELISTENER" _OUTER_CALL_ (window, 6, mousef);
	}

	onKeyPress(ref function) => {
		var keyf = (a, b, c) => {
			return function(new KeyEvent(a, b, c));
		}
		"LIB_Graphics.ADDKEYLISTENER" _OUTER_CALL_ (window, 0, keyf);
	}

	onKeyRelease(ref function) => {
		var keyf = (a, b, c) => {
			return function(new KeyEvent(a, b, c));
		}
		"LIB_Graphics.ADDKEYLISTENER" _OUTER_CALL_ (window, 1, keyf);
	}

	onKeyType(ref function) => {
		var keyf = (a, b, c) => {
			return function(new KeyEvent(a, b, c));
		}
		"LIB_Graphics.ADDKEYLISTENER" _OUTER_CALL_ (window, 2, keyf);
	}

	struct Graphics class {
		var graphics;

		init(ref graphics) => {
			this.graphics = graphics;
		}

		add(ref shape) => {
			var success = ("LIB_Graphics.GRAPHICS.ADD" _OUTER_CALL_ (this.graphics, shape.data));
			success == false then {
				throw "Shape already exists in Graphics";
			}
		}

		remove(ref shape) => {
			"LIB_Graphics.GRAPHICS.REMOVE" _OUTER_CALL_ (this.graphics, shape.data);
			success == false then {
				throw "Shape does not exist in Graphics";
			}
		}
	}

	struct MouseEvent class {
		var button;
		var clickCount;
		var modifiers;
		var x;
		var y;
		var screenX;
		var screenY;

		init(final button, final clickCount, final modifiers, final x, final y, final screenX, final screenY) => {
			this.button = button;
			this.clickCount = clickCount;
			this.modifiers = modifiers;
			this.x = x;
			this.y = y;
			this.screenX = screenX;
			this.screenY = screenY;
		}

		getStr() => {
			return "(BUTTON=" + str button + ", COUNT=" + str clickCount + ", MODIFIERS=" + str modifiers + ", X=" + str x + ", Y=" + str y + ", SCREEN_X=" + str screenX + ", SCREEN_Y=" + str screenY + ")";
		}
	}

	struct KeyEvent class {
		var charCode;
		var charStr;
		var actionKey;

		init(final charCode, final charStr, final actionKey) => {
			this.charCode = charCode;
			this.charStr = charStr;
			this.actionKey = actionKey;
		}

		getStr() => {
			return "(CODE=" + str charCode + ", STR=" + charStr + ", ISACTION=" + str actionKey + ")";
		}
	}
}

static Shape class {
	var LEFT = 0;
	var CENTER = 1;
	var RIGHT = 2;

	struct Rectangle class {
		var data;

		var fill;
		var outline;
		var x;
		var y;
		var width;
		var height;

		init(ref fill, ref outline, final x, final y, final width, final height) => {
			this.fill = fill;
			this.outline = outline;
			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;
			fill == null then {
				this.data = ("LIB_Graphics.SHAPE.RECTANGLE.INIT" _OUTER_CALL_ (null, outline.data, x, y, width, height));
			} else outline == null then {
				this.data = ("LIB_Graphics.SHAPE.RECTANGLE.INIT" _OUTER_CALL_ (fill.data, null, x, y, width, height));
			} else {
				this.data = ("LIB_Graphics.SHAPE.RECTANGLE.INIT" _OUTER_CALL_ (fill.data, outline.data, x, y, width, height));
			}
		}

		setFill(ref fill) => {
			this.fill = fill;
			"LIB_Graphics.SHAPE.SETFILL" _OUTER_CALL_ (data, fill.data);
		}

		setOutline(ref outline) => {
			this.outline = outline;
			"LIB_Graphics.SHAPE.SETOUTLINE" _OUTER_CALL_ (data, outline);
		}

		setSize(final width, final height) => {
			this.width = width;
			this.height = height;
			"LIB_Graphics.SHAPE.RECTANGLE.SIZE" _OUTER_CALL_ (this.data, width, height);
		}

		setOrigin(final x, final y) => {
			this.x = x;
			this.y = y;
			"LIB_Graphics.SHAPE.RECTANGLE.MOVE" _OUTER_CALL_ (this.data, x, y);
		}

		move(final x, final y) => {
			this.x += x;
			this.y += y;
			"LIB_Graphics.SHAPE.RECTANGLE.MOVE" _OUTER_CALL_ (this.data, this.x, this.y);
		}
	}

	struct Oval class {
		var data;

		var fill;
		var outline;
		var x;
		var y;
		var width;
		var height;

		init(ref fill, ref outline, final x, final y, final width, final height) => {
			this.fill = fill;
			this.outline = outline;
			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;
			fill == null then {
				this.data = ("LIB_Graphics.SHAPE.OVAL.INIT" _OUTER_CALL_ (null, outline.data, x, y, width, height));
			} else outline == null then {
				this.data = ("LIB_Graphics.SHAPE.OVAL.INIT" _OUTER_CALL_ (fill.data, null, x, y, width, height));
			} else {
				this.data = ("LIB_Graphics.SHAPE.OVAL.INIT" _OUTER_CALL_ (fill.data, outline.data, x, y, width, height));
			}
		}

		setFill(ref fill) => {
			this.fill = fill;
			"LIB_Graphics.SHAPE.SETFILL" _OUTER_CALL_ (data, fill.data);
		}

		setOutline(ref outline) => {
			this.outline = outline;
			"LIB_Graphics.SHAPE.SETOUTLINE" _OUTER_CALL_ (data, outline.data);
		}

		setSize(final width, final height) => {
			this.width = width;
			this.height = height;
			"LIB_Graphics.SHAPE.OVAL.SIZE" _OUTER_CALL_ (this.data, width, height);
		}

		setOrigin(final x, final y) => {
			this.x = x;
			this.y = y;
			"LIB_Graphics.SHAPE.OVAL.MOVE" _OUTER_CALL_ (this.data, x, y);
		}

		move(final x, final y) => {
			this.x += x;
			this.y += y;
			"LIB_Graphics.SHAPE.OVAL.MOVE" _OUTER_CALL_ (this.data, this.x, this.y);
		}
	}

	struct Line class {
		var data;

		var fill;
		var x1;
		var y1;
		var x2;
		var y2;

		init(ref fill, final x1, final y1, final x2, final y2) => {
			this.fill = fill;
			this.x1 = x1;
			this.y1 = y1;
			this.x2 = x2;
			this.y2 = y2;
			this.data = ("LIB_Graphics.SHAPE.LINE.INIT" _OUTER_CALL_ (fill.data, x1, y1, x2, y2));
		}

		setFill(ref fill) => {
			this.fill = fill;
			"LIB_Graphics.SHAPE.SETFILL" _OUTER_CALL_ (data, fill.data);
		}

		setPoints(final x1, final y1, final x2, final y2) => {
			this.x1 = x1;
			this.y1 = y1;
			this.x2 = x2;
			this.y2 = y2;
			"LIB_Graphics.SHAPE.LINE.MOVE" _OUTER_CALL_ (this.data, this.x1, this.y1, this.x2, this.y2);
		}

		move(final x, final y) => {
			this.x1 += x;
			this.x2 += x;
			this.y1 += y;
			this.y2 += y;
			"LIB_Graphics.SHAPE.LINE.MOVE" _OUTER_CALL_ (this.data, this.x1, this.y1, this.x2, this.y2);
		}
	}

	struct Text class {
		var data;

		var fill;
		var x;
		var y;
		var string;
		var font;
		var align;

		init(ref fill, final x, final y, final string, final align) => {
			this.fill = fill;
			this.x = x;
			this.y = y;
			this.string = string;
			this.align = align;
			this.data = ("LIB_Graphics.SHAPE.TEXT.INIT" _OUTER_CALL_ (fill.data, x, y, string, align));
		}

		setFill(ref fill) => {
			this.fill = fill;
			"LIB_Graphics.SHAPE.SETFILL" _OUTER_CALL_ (data, fill.data);
		}

		setFont(ref font) => {
			this.font = font;
			"LIB_Graphics.SHAPE.TEXT.SETFONT" _OUTER_CALL_ (data, font.font);
		}

		setText(final string) => {
			this.string = string;
			"LIB_Graphics.SHAPE.TEXT.SETSTRING" _OUTER_CALL_ (data, string);
		}

		setOrigin(final x, final y) => {
			this.x = x;
			this.y = y;
			"LIB_Graphics.SHAPE.TEXT.MOVE" _OUTER_CALL_ (data, x, y);
		}

		move(final x, final y) => {
			this.x += x;
			this.y += y;
			"LIB_Graphics.SHAPE.TEXT.MOVE" _OUTER_CALL_ (data, this.x, this.y);
		}
	}
}

struct Font class {
	var font;
	var fontName;
	var style;
	var size;

	init(final fontName, final style, final size) => {
		this.fontName = fontName;
		this.style = style;
		this.size = size;
		this.font = ("LIB_Graphics.FONT.INIT" _OUTER_CALL_ (fontName, style, size));
	}

	getStr() => {
		return "(" + str fontName + ", " + str style + ", " + str size + ")";
	}
}

static Color class {
	struct RGB class {
		var r;
		var g;
		var b;
		var a;
		var data;

		init(final r, final g, final b, final a) => {
			this.r = r;
			this.g = g;
			this.b = b;
			a == null then {
				this.a = 255;
			} else {
				this.a = a;
			}
			this.data = ("LIB_Graphics.COLOR.INIT" _OUTER_CALL_ (r, g, b, this.a));
		}

		getStr() => {
			return "(" + str r + ", " + str g + ", " + str b + ", " + str a + ")";
		}
	}

	HSLtoRGB(final h, final s, final l, final a) => {
		var hueToRgb = (final p, final q, t) => {
			t < 0 then {
				t += 1;
			} else t > 1 then {
				t -= 1;
			}
			t < 1/6 then {
				return p + (q - p) * 6 * t;
			}
			t < 1/2 then {
				return q;
			}
			t < 2/3 then {
				return p + (q - p) * (2/3 - t) * 6;
			}
			return p;
		}
		var r;
		var g;
		var b;
		s == 0 then {
			r = l;
			g = l;
			b = l;
		} else {
			var q = (l < 0.5 then (l * (1 + s)) else (l + s - l * s));
			var p = 2 * l - q;
			r = hueToRgb(p, q, h + 1/3);
			g = hueToRgb(p, q, h);
			b = hueToRgb(p, q, h - 1/3);
		}
		r *= 256;
		g *= 256;
		b *= 256;
		r > 255 then { r = 255 };
		g > 255 then { g = 255 };
		b > 255 then { b = 255 };
		return new RGB(r, g, b, a);
	}

	var RED = new RGB(255, 0, 0, 255);
	var GREEN = new RGB(0, 255, 0, 255);
	var BLUE = new RGB(0, 0, 255, 255);
	var BLACK = new RGB(0, 0, 0, 255);
	var WHITE = new RGB(255, 255, 255, 255);
	var GRAY = new RGB(200, 200, 200, 255);
	var ALPHA = new RGB(0, 0, 0, 0);
}