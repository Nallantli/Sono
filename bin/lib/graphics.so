# Benjamin Park
# 27-07-2020

import "LIB_Graphics";

struct Window class {
	var width;
	var height;
	var window;
	var component;
	var graphics;

	init(final title, final width, final height, ref closefunction) => {
		this.width = width;
		this.height = height;
		var data = ("LIB_Graphics.INIT" _OUTER_CALL_ (title, width, height, closefunction));
		this.window = data[0];
		this.component = data[1];
	}

	show() => {
		"LIB_Graphics.SHOW" _OUTER_CALL_ (this.window);
	}

	hide() => {
		"LIB_Graphics.HIDE" _OUTER_CALL_ (this.window);
	}

	resize(final width, final height) => {
		"LIB_Graphics.SETSIZE" _OUTER_CALL_ (window, width, height);
		this.width = width;
		this.height = height;
	}

	add(ref child, ref position) => {
		"LIB_Graphics.COMPONENT.ADD" _OUTER_CALL_ (component, child.component, position);
		return child;
	}

	close() => {
		"LIB_Graphics.CLOSE" _OUTER_CALL_ (this.window);
		this.window = null;
	}

	getGraphics() => {
		this.graphics == null then {
			this.graphics = new Component.Graphics();
			add(this.graphics, "Center");
		}
		refer this.graphics;
	}

	repaint() => {
		"LIB_Graphics.REPAINT" _OUTER_CALL_ (window);
	}

	onMouseMove(ref function) => {
		var mousef = (a, b, c, d, e, f, g) => {
			refer function(new MouseEvent(a, b, c, d, e, f, g));
		}
		"LIB_Graphics.ADDMOUSELISTENER" _OUTER_CALL_ (window, 0, mousef);
	}

	onMouseDrag(ref function) => {
		var mousef = (a, b, c, d, e, f, g) => {
			refer function(new MouseEvent(a, b, c, d, e, f, g));
		}
		"LIB_Graphics.ADDMOUSELISTENER" _OUTER_CALL_ (window, 1, mousef);
	}

	onMouseRelease(ref function) => {
		var mousef = (a, b, c, d, e, f, g) => {
			refer function(new MouseEvent(a, b, c, d, e, f, g));
		}
		"LIB_Graphics.ADDMOUSELISTENER" _OUTER_CALL_ (window, 2, mousef);
	}

	onMousePress(ref function) => {
		var mousef = (a, b, c, d, e, f, g) => {
			refer function(new MouseEvent(a, b, c, d, e, f, g));
		}
		"LIB_Graphics.ADDMOUSELISTENER" _OUTER_CALL_ (window, 3, mousef);
	}

	onMouseExit(ref function) => {
		var mousef = (a, b, c, d, e, f, g) => {
			refer function(new MouseEvent(a, b, c, d, e, f, g));
		}
		"LIB_Graphics.ADDMOUSELISTENER" _OUTER_CALL_ (window, 4, mousef);
	}

	onMouseEnter(ref function) => {
		var mousef = (a, b, c, d, e, f, g) => {
			refer function(new MouseEvent(a, b, c, d, e, f, g));
		}
		"LIB_Graphics.ADDMOUSELISTENER" _OUTER_CALL_ (window, 5, mousef);
	}

	onMouseClick(ref function) => {
		var mousef = (a, b, c, d, e, f, g) => {
			refer function(new MouseEvent(a, b, c, d, e, f, g));
		}
		"LIB_Graphics.ADDMOUSELISTENER" _OUTER_CALL_ (window, 6, mousef);
	}

	onKeyPress(ref function) => {
		var keyf = (a, b, c) => {
			refer function(new KeyEvent(a, b, c));
		}
		"LIB_Graphics.ADDKEYLISTENER" _OUTER_CALL_ (window, 0, keyf);
	}

	onKeyRelease(ref function) => {
		var keyf = (a, b, c) => {
			refer function(new KeyEvent(a, b, c));
		}
		"LIB_Graphics.ADDKEYLISTENER" _OUTER_CALL_ (window, 1, keyf);
	}

	onKeyType(ref function) => {
		var keyf = (a, b, c) => {
			refer function(new KeyEvent(a, b, c));
		}
		"LIB_Graphics.ADDKEYLISTENER" _OUTER_CALL_ (window, 2, keyf);
	}

	getHash() => {
		return hash window;
	}

	equals(ref o) => {
		type(this) != type(o) then {
			return false;
		}
		return window == o.window;
	}

	struct MouseEvent class {
		var button;
		var clickCount;
		var modifiers;
		var x;
		var y;
		var screenX;
		var screenY;

		init(final button, final clickCount, final modifiers, final x, final y, final screenX, final screenY) => {
			this.button = button;
			this.clickCount = clickCount;
			this.modifiers = modifiers;
			this.x = x;
			this.y = y;
			this.screenX = screenX;
			this.screenY = screenY;
		}

		getStr() => {
			return "(BUTTON=" + str button + ", COUNT=" + str clickCount + ", MODIFIERS=" + str modifiers + ", X=" + str x + ", Y=" + str y + ", SCREEN_X=" + str screenX + ", SCREEN_Y=" + str screenY + ")";
		}
	}

	struct KeyEvent class {
		var charCode;
		var charStr;
		var actionKey;

		init(final charCode, final charStr, final actionKey) => {
			this.charCode = charCode;
			this.charStr = charStr;
			this.actionKey = actionKey;
		}

		getStr() => {
			return "(CODE=" + str charCode + ", STR=" + charStr + ", ISACTION=" + str actionKey + ")";
		}
	}
}

static Component class {
	var NORTH = "North";
	var SOUTH = "South";
	var EAST = "East";
	var WEST = "West";
	var MIDDLE = "Center";

	var CENTER = 0;
	var TOP = 1;
	var LEFT = 2;
	var BOTTOM = 3;
	var RIGHT = 4;
	var LEADING = 10;

	abstract Prototype class {
		var component;

		add(ref child) => {
			"LIB_Graphics.COMPONENT.ADD" _OUTER_CALL_ (component, child.component);
			refer child;
		}

		getHash() => {
			return hash component;
		}

		equals(ref o) => {
			type(this) != type(o) then {
				return false;
			}
			return component == o.component;
		}
	}

	abstract Actionable extends Prototype class {
		var enabled;

		enable() => {
			this.enabled = true;
			"LIB_Graphics.COMPONENT.SETENABLE" _OUTER_CALL_ (component, true);
		}

		disable() => {
			this.enabled = false;
			"LIB_Graphics.COMPONENT.SETENABLE" _OUTER_CALL_ (component, false);
		}

		action(ref function) => {
			"LIB_Graphics.COMPONENT.ACTION" _OUTER_CALL_ (component, function);
		}

		click() => {
			"LIB_Graphics.COMPONENT.CLICK" _OUTER_CALL_ component;
		}
	}

	struct Graphics extends Prototype class {
		init() => {
			this.component = ("LIB_Graphics.GRAPHICS.INIT" _OUTER_CALL_ null);
		}

		add(ref shape) => {
			var success = ("LIB_Graphics.GRAPHICS.ADD" _OUTER_CALL_ (this.component, shape.data));
			success == false then {
				throw "Shape already exists in Graphics";
			}
			refer shape;
		}

		remove(ref shape) => {
			"LIB_Graphics.GRAPHICS.REMOVE" _OUTER_CALL_ (this.component, shape.data);
			success == false then {
				throw "Shape does not exist in Graphics";
			}
		}
	}

	struct Text extends Prototype class {
		var label;
		var alignmentX;
		var alignmentY;

		init(final label) => {
			this.label = label;
			this.component = ("LIB_Graphics.COMPONENT.TEXT.INIT" _OUTER_CALL_ label);
		}

		align(final alignmentX, final alignmentY) => {
			this.alignmentX = alignmentX;
			this.alignmentY	= alignmentY;
			"LIB_Graphics.COMPONENT.TEXT.ALIGN" _OUTER_CALL_ (component, alignmentX, alignmentY);
		}

		setText(final label) => {
			this.label = label;
			"LIB_Graphics.COMPONENT.TEXT.SETTEXT" _OUTER_CALL_ (component, label);
		}
	}

	struct Button extends Actionable class {
		var label;

		init(final label) => {
			this.label = label;
			this.component = ("LIB_Graphics.COMPONENT.BUTTON.INIT" _OUTER_CALL_ label);
		}

		setText(final label) => {
			this.label = label;
			"LIB_Graphics.COMPONENT.BUTTON.SETTEXT" _OUTER_CALL_ (component, label);
		}
	}

	struct CheckBox extends Actionable class {
		var label;

		init(final label) => {
			this.label = label;
			this.component = ("LIB_Graphics.COMPONENT.CHECKBOX.INIT" _OUTER_CALL_ label);
		}

		setText(final label) => {
			this.label = label;
			"LIB_Graphics.COMPONENT.CHECKBOX.SETTEXT" _OUTER_CALL_ (component, label);
		}
	}

	static Panel class {
		struct Border extends Prototype class {
			init() => {
				this.component = ("LIB_Graphics.COMPONENT.PANEL.BORDER.INIT" _OUTER_CALL_ null);
			}
		}

		struct Block extends Prototype class {
			init() => {
				this.component = ("LIB_Graphics.COMPONENT.PANEL.BLOCK.INIT" _OUTER_CALL_ null);
			}
		}

		struct Inline extends Prototype class {
			init() => {
				this.component = ("LIB_Graphics.COMPONENT.PANEL.INLINE.INIT" _OUTER_CALL_ null);
			}
		}

		struct Table extends Prototype class {
			var rows;
			var cols;

			init(final rows, final cols) => {
				this.rows = rows;
				this.cols = cols;
				this.component = ("LIB_Graphics.COMPONENT.PANEL.TABLE.INIT" _OUTER_CALL_ (rows, cols));
			}
		}

		struct Split extends Prototype class {
			var orientation;

			init(final orientation) => {
				this.orientation = orientation;
				this.component = ("LIB_Graphics.COMPONENT.PANEL.SPLIT.INIT" _OUTER_CALL_ orientation);
			}
		}
	}

	struct TabPane extends Prototype class {
		init() => {
			this.component = ("LIB_Graphics.COMPONENT.TABPANE.INIT" _OUTER_CALL_ null);
		}

		add(final label, ref child) => {
			"LIB_Graphics.COMPONENT.TABPANE.ADD" _OUTER_CALL_ (component, child.component, label);
			refer child;
		}
	}

	static Menu class {
		struct Bar extends Prototype class {
			init() => {
				this.component = ("LIB_Graphics.COMPONENT.MENU.BAR.INIT" _OUTER_CALL_ null);
			}
		}

		struct Item extends Prototype class {
			var label;

			init(final label) => {
				this.label = label;
				this.component = ("LIB_Graphics.COMPONENT.MENU.ITEM.INIT" _OUTER_CALL_ label);
			}
		}

		struct Label extends Actionable class {
			var label;

			init(final label) => {
				this.label = label;
				this.component = ("LIB_Graphics.COMPONENT.MENU.LABEL.INIT" _OUTER_CALL_ label);
			}
		}
	}
}

static Shape class {
	var LEFT = 0;
	var CENTER = 1;
	var RIGHT = 2;

	struct Rectangle class {
		var data;

		var fill;
		var outline;
		var x;
		var y;
		var width;
		var height;

		init(ref fill, ref outline, final x, final y, final width, final height) => {
			this.fill = fill;
			this.outline = outline;
			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;
			fill == null then {
				this.data = ("LIB_Graphics.SHAPE.RECTANGLE.INIT" _OUTER_CALL_ (null, outline.data, x, y, width, height));
			} else outline == null then {
				this.data = ("LIB_Graphics.SHAPE.RECTANGLE.INIT" _OUTER_CALL_ (fill.data, null, x, y, width, height));
			} else {
				this.data = ("LIB_Graphics.SHAPE.RECTANGLE.INIT" _OUTER_CALL_ (fill.data, outline.data, x, y, width, height));
			}
		}

		setFill(ref fill) => {
			fill != this.fill then {
				this.fill = fill;
				"LIB_Graphics.SHAPE.SETFILL" _OUTER_CALL_ (data, fill.data);
			}
		}

		setOutline(ref outline) => {
			outline != this.outline then {
				this.outline = outline;
				"LIB_Graphics.SHAPE.SETOUTLINE" _OUTER_CALL_ (data, outline.data);
			}
		}

		setSize(final width, final height) => {
			this.width = width;
			this.height = height;
			"LIB_Graphics.SHAPE.RECTANGLE.SIZE" _OUTER_CALL_ (this.data, width, height);
		}

		setOrigin(final x, final y) => {
			this.x = x;
			this.y = y;
			"LIB_Graphics.SHAPE.RECTANGLE.MOVE" _OUTER_CALL_ (this.data, x, y);
		}

		move(final x, final y) => {
			this.x += x;
			this.y += y;
			"LIB_Graphics.SHAPE.RECTANGLE.MOVE" _OUTER_CALL_ (this.data, this.x, this.y);
		}
	}

	struct Oval class {
		var data;

		var fill;
		var outline;
		var x;
		var y;
		var width;
		var height;

		init(ref fill, ref outline, final x, final y, final width, final height) => {
			this.fill = fill;
			this.outline = outline;
			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;
			fill == null then {
				this.data = ("LIB_Graphics.SHAPE.OVAL.INIT" _OUTER_CALL_ (null, outline.data, x, y, width, height));
			} else outline == null then {
				this.data = ("LIB_Graphics.SHAPE.OVAL.INIT" _OUTER_CALL_ (fill.data, null, x, y, width, height));
			} else {
				this.data = ("LIB_Graphics.SHAPE.OVAL.INIT" _OUTER_CALL_ (fill.data, outline.data, x, y, width, height));
			}
		}

		setFill(ref fill) => {
			fill != this.fill then {
				this.fill = fill;
				"LIB_Graphics.SHAPE.SETFILL" _OUTER_CALL_ (data, fill.data);
			}
		}

		setOutline(ref outline) => {
			outline != this.outline then {
				this.outline = outline;
				"LIB_Graphics.SHAPE.SETOUTLINE" _OUTER_CALL_ (data, outline.data);
			}
		}

		setSize(final width, final height) => {
			this.width = width;
			this.height = height;
			"LIB_Graphics.SHAPE.OVAL.SIZE" _OUTER_CALL_ (this.data, width, height);
		}

		setOrigin(final x, final y) => {
			this.x = x;
			this.y = y;
			"LIB_Graphics.SHAPE.OVAL.MOVE" _OUTER_CALL_ (this.data, x, y);
		}

		move(final x, final y) => {
			this.x += x;
			this.y += y;
			"LIB_Graphics.SHAPE.OVAL.MOVE" _OUTER_CALL_ (this.data, this.x, this.y);
		}
	}

	struct Line class {
		var data;

		var fill;
		var x1;
		var y1;
		var x2;
		var y2;

		init(ref fill, final x1, final y1, final x2, final y2) => {
			this.fill = fill;
			this.x1 = x1;
			this.y1 = y1;
			this.x2 = x2;
			this.y2 = y2;
			this.data = ("LIB_Graphics.SHAPE.LINE.INIT" _OUTER_CALL_ (fill.data, x1, y1, x2, y2));
		}

		setFill(ref fill) => {
			fill != this.fill then {
				this.fill = fill;
				"LIB_Graphics.SHAPE.SETFILL" _OUTER_CALL_ (data, fill.data);
			}
		}

		setPoints(final x1, final y1, final x2, final y2) => {
			this.x1 = x1;
			this.y1 = y1;
			this.x2 = x2;
			this.y2 = y2;
			"LIB_Graphics.SHAPE.LINE.MOVE" _OUTER_CALL_ (this.data, this.x1, this.y1, this.x2, this.y2);
		}

		move(final x, final y) => {
			this.x1 += x;
			this.x2 += x;
			this.y1 += y;
			this.y2 += y;
			"LIB_Graphics.SHAPE.LINE.MOVE" _OUTER_CALL_ (this.data, this.x1, this.y1, this.x2, this.y2);
		}
	}

	struct Text class {
		var data;

		var fill;
		var x;
		var y;
		var string;
		var font;
		var align;

		init(ref fill, final x, final y, final string, final align) => {
			this.fill = fill;
			this.x = x;
			this.y = y;
			this.string = string;
			this.align = align;
			this.data = ("LIB_Graphics.SHAPE.TEXT.INIT" _OUTER_CALL_ (fill.data, x, y, string, align));
		}

		setFill(ref fill) => {
			fill != this.fill then {
				this.fill = fill;
				"LIB_Graphics.SHAPE.SETFILL" _OUTER_CALL_ (data, fill.data);
			}
		}

		setFont(ref font) => {
			this.font = font;
			"LIB_Graphics.SHAPE.TEXT.SETFONT" _OUTER_CALL_ (data, font.font);
		}

		setText(final string) => {
			this.string = string;
			"LIB_Graphics.SHAPE.TEXT.SETSTRING" _OUTER_CALL_ (data, string);
		}

		setOrigin(final x, final y) => {
			this.x = x;
			this.y = y;
			"LIB_Graphics.SHAPE.TEXT.MOVE" _OUTER_CALL_ (data, x, y);
		}

		move(final x, final y) => {
			this.x += x;
			this.y += y;
			"LIB_Graphics.SHAPE.TEXT.MOVE" _OUTER_CALL_ (data, this.x, this.y);
		}
	}
}

struct Font class {
	var font;
	var fontName;
	var style;
	var size;

	init(final fontName, final style, final size) => {
		this.fontName = fontName;
		this.style = style;
		this.size = size;
		this.font = ("LIB_Graphics.FONT.INIT" _OUTER_CALL_ (fontName, style, size));
	}

	getStr() => {
		return "(" + str fontName + ", " + str style + ", " + str size + ")";
	}
}

static Color class {
	struct RGB class {
		var r;
		var g;
		var b;
		var a;
		var data;

		init(final r, final g, final b, final a) => {
			this.r = r;
			this.g = g;
			this.b = b;
			a == null then {
				this.a = 255;
			} else {
				this.a = a;
			}
			this.data = ("LIB_Graphics.COLOR.INIT" _OUTER_CALL_ (r, g, b, this.a));
		}

		getStr() => {
			return "(" + str r + ", " + str g + ", " + str b + ", " + str a + ")";
		}

		equals(ref o) => {
			type(o) != type(this) then {
				return false;
			}
			return r == o.r && g == o.g && b == o.b && a == o.a;
		}
	}

	HSLtoRGB(final h, final s, final l, final a) => {
		var hueToRgb = (final p, final q, t) => {
			t < 0 then {
				t += 1;
			} else t > 1 then {
				t -= 1;
			}
			t < 1/6 then {
				return p + (q - p) * 6 * t;
			}
			t < 1/2 then {
				return q;
			}
			t < 2/3 then {
				return p + (q - p) * (2/3 - t) * 6;
			}
			return p;
		}
		var r;
		var g;
		var b;
		s == 0 then {
			r = l;
			g = l;
			b = l;
		} else {
			var q = (l < 0.5 then (l * (1 + s)) else (l + s - l * s));
			var p = 2 * l - q;
			r = hueToRgb(p, q, h + 1/3);
			g = hueToRgb(p, q, h);
			b = hueToRgb(p, q, h - 1/3);
		}
		r *= 256;
		g *= 256;
		b *= 256;
		r = (r > 255 then 255 else r);
		g = (g > 255 then 255 else g);
		b = (b > 255 then 255 else b);
		return new RGB(r, g, b, a);
	}

	var RED = new RGB(255, 0, 0, 255);
	var GREEN = new RGB(0, 255, 0, 255);
	var BLUE = new RGB(0, 0, 255, 255);
	var BLACK = new RGB(0, 0, 0, 255);
	var WHITE = new RGB(255, 255, 255, 255);
	var GRAY = new RGB(200, 200, 200, 255);
	var ALPHA = new RGB(0, 0, 0, 0);
}