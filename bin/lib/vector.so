Vector::pop(ref this) => {
	var nl = {};
	i in {0 until (len this - 1)} do {
		nl += { this[i] };
	};
	this = nl;
	return this;
};

Vector::shift(ref this) => {
	var nl = {};
	i in {1 until len this} do {
		nl += { this[i] };
	};
	this = nl;
	return this;
};

Vector::front(ref this) => {
	return this[0];
};

Vector::back(ref this) => {
	return this[len this - 1];
};

Vector::isEmpty(ref this) => {
	return (len this == 0);
};

Vector::contains(ref this, final value) => {
	i in this do {
		i == value then {
			return true;
		};
	};
	return false;
};

Vector::push(ref this, ref value) => {
	this += { value };
	return this;
};

Vector::join(final this, del) => {
	del == null then {
		del = "";
	};
	var string = "";
	e in this do {
		string += str e;
	};
	return string;
};

Vector::reverse(ref this) => {
	var nv = {};
	i in {0 until len this} do {
		nv += { this[len this - i - 1] };
	};
	this = nv;
	return this;
};

Vector::remove(ref this, final index) => {
	var nv = {};
	i in {0 until len this} do {
		i != index then {
			nv += { this[i] };
		}
	};
	this = nv;
	return this;
};

Vector::dist(final this, final raw, costDel, costIns, costRep) => {
	var vector = raw;
	type raw != "Vector" then {
		vector = vec raw;
	};
	costDel == null then {
		costDel = 1;
	};
	costIns == null then {
		costIns = 1;
	};
	costRep == null then {
		costRep = 1;
	};

	var m = len this;
	var n = len vector;
	var array = {0 until (m + 1)};
	i in array do {
		i = {0 until (n + 1)};
		j in i do {
			j = 0;
		};
	};
	i in {1 until (m + 1)} do {
		array[i][0] = i;
	};
	i in {1 until (n + 1)} do {
		array[0][i] = i;
	};

	i in {1 until (m + 1)} do {
		j in {1 until (n + 1)} do {
			array[i][j] = Math.min({
				array[i - 1][j] + costDel,	# DELETION
				array[i][j - 1] + costIns,	# INSERTION
				array[i - 1][j - 1] + (this[i - 1] != vector[j - 1]) * costRep	# REPLACEMENT
			});
		};
	};

	return array[m][n];
};

Vector::nGram(final this, final n) => {
	var nv = {};
	i in {0 until (len this - n + 1)} do {
		var gram = {};
		j in {0 until n} do {
			gram += {this[i + j]};
		};
		nv += {gram};
	};
	return nv;
};

Vector::sort(ref this, comp) => {
	comp == null then {
		comp = (a, b) => { return a < b; };
	} else type comp != "Function" then {
		throw "Parameter <comp> of Vector::sort() must be of type Function";
	};
	Vector::merge_sort(ref this) => {
		len this <= 1 then {
			return this;
		};
		var a = {};
		var b = {};
		i in {1 until len this} do {
			comp(this[i], this[0]) then {
				a += { this[i] };
			} else {
				b += { this[i] };
			};
		};
		this = a.merge_sort() + { this[0] } + b.merge_sort();
		return this;
	};
	return this.merge_sort();
};