# Benjamin Park
# Vector::steps() adapted from https://gist.github.com/kylebgorman/1081951 by Kyle Gorman
# 26-08-2020

Vector::pop(ref this) => {
	var nl = alloc(length(this) - 1);
	i in {0 until length(nl)} do {
		nl[i] = this[i];
	}
	this = nl;
	refer this;
}

Vector::shift(ref this) => {
	var nl = alloc(length(this) - 1);
	i in {1 until length(this)} do {
		nl[i - 1] = this[i];
	}
	this = nl;
	refer this;
}

Vector::front(ref this) => {
	refer this[0];
}

Vector::back(ref this) => {
	refer this[length(this) - 1];
}

Vector::isEmpty(ref this) => {
	return (length(this) == 0);
}

Vector::contains(ref this, ref value) => {
	i in this do {
		i == value then {
			return true;
		}
	}
	return false;
}

Vector::push(ref this, ref value) => {
	this += { value };
	refer this;
}

Vector::join(ref this) => {
	var string = "";
	e in this do {
		string += str e;
	}
	return string;
}

Vector::remove(ref this, final index) => {
	var nv = alloc(length(this) - 1);
	var j = 0;
	i in {0 until length(this)} do {
		i != index then {
			nv[j] = this[i];
			j += 1;
		}
	}
	this = nv;
	refer this;
}

Vector::reverse(final this) => {
	var nv = alloc(length(this));
	i in {0 until length(this)} do {
		nv[i] = this[length(this) - i - 1];
	}
	return nv;
}

Vector::set(ref this, ref value) => {
	e in this do {
		type(e) == "Vector" then {
			e.set(value);
		} else {
			e = value;
		}
	}
	refer this;
}

Vector::distArray(ref this, ref vector, costDel, costIns, costRep) => {
	costDel == null then {
		costDel = 1;
	}
	costIns == null then {
		costIns = 1;
	}
	costRep == null then {
		costRep = 1;
	}

	var m = length(this);
	var n = length(vector);
	var array = alloc(m + 1, n + 1).set(0);

	i in {1 until (m + 1)} do {
		array[i][0] = i;
	}
	i in {1 until (n + 1)} do {
		array[0][i] = i;
	}

	i in {1 until (m + 1)} do {
		j in {1 until (n + 1)} do {
			array[i][j] = Math.min({
				array[i - 1][j] + costDel,	# DELETION
				array[i][j - 1] + costIns,	# INSERTION
				array[i - 1][j - 1] + (this[i - 1] != vector[j - 1] then 1 else 0) * costRep	# REPLACEMENT
			});
		}
	}

	return array;
}

Vector::dist(ref this, ref vector, final costDel, final costIns, final costRep) => {
	return this.distArray(vector, costDel, costIns, costRep)[length(this)][length(vector)];
}

Vector::steps(ref this, ref vector, final costDel, final costIns, final costRep) => {
	var D = this.distArray(vector, costDel, costIns, costRep);
	var i = length(this);
	var j = length(vector);
	var steps = {};
	true do {
		i > 0 then {
			j > 0 then {
				D[i - 1][j] <= D[i][j - 1] then {
					D[i - 1][j] < D[i - 1][j - 1] then {
						steps += {{"DEL", i - 1, this[i - 1]}};
					} else {
						D[i][j] != D[i - 1][j - 1] then {
							steps += {{"SUB", i - 1, this[i - 1], vector[j - 1]}};
						}
						j -= 1;
					}
					i -= 1;
				} else {
					D[i][j - 1] <= D[i - 1][j - 1] then {
						steps += {{"INS", i - 1, vector[j - 1]}};
					} else {
						D[i][j] != D[i - 1][j - 1] then {
							steps += {{"SUB", i - 1, this[i - 1], vector[j - 1]}};
						}
						i -= 1;
					}
					j -= 1;
				}
			} else {
				steps += {{"DEL", i - 1, this[i - 1]}};
				i -= 1;
			}
		} else j > 0 then {
			steps += {{"DEL", i - 1, this[i - 1]}};
			j -= 1;
		} else {
			return steps.reverse();
		}
	}
}

Vector::nGram(ref this, final n) => {
	var nv = {};
	i in {0 until (length(this) - n + 1)} do {
		var gram = {};
		j in {0 until n} do {
			gram += {this[i + j]};
		}
		nv += {gram};
	}
	return nv;
}

Vector::sort(ref this, comp) => {
	comp == null then {
		comp = (a, b) => { return a < b; };
	} else type(comp) != "Function" then {
		throw "Parameter <comp> of Vector::sort() must be of type Function";
	}
	Vector::merge_sort(final this) => {
		length(this) <= 1 then {
			return this;
		}
		var a = {};
		var b = {};
		i in {1 until length(this)} do {
			comp(this[i], this[0]) then {
				a += { this[i] };
			} else {
				b += { this[i] };
			}
		}
		return a.merge_sort() + { this[0] } + b.merge_sort();
	}
	return this.merge_sort();
}

Vector::map(ref this, ref function) => {
	var nl = alloc(length(this));
	i in {0 until length(this)} do {
		nl[i] = function(this[i]);
	}
	return nl;
}

Vector::filter(ref this, ref function) => {
	var nl = {};
	e in this do {
		function(e) then {
			nl += { e };
		}
	}
	return nl;
}

Vector::foldRight(ref this, ref function) => {
	length(this) == 1 then {
		return this[0];
	}
	var nl = this;
	return function(this[0], nl.shift().foldRight(function));
}

Vector::foldLeft(ref this, ref function) => {
	length(this) == 1 then {
		return this[0];
	}
	var nl = this;
	return function(nl.pop().foldLeft(function), this[length(this) - 1]);
}

Vector::randomize(ref this) => {
	var temp = this;
	var nv = alloc(length(this));
	i in {0 until length(this)} do {
		var index = Random.int(0, length(temp));
		nv[i] = temp[index];
		temp.remove(index);
	}
	return nv;
}