# Benjamin Park
# Vector::steps() adapted from https://gist.github.com/kylebgorman/1081951 by Kyle Gorman
# 29-06-2020

load "math";

Vector::pop(ref this) => {
	var nl = {};
	i in {0 until (len this - 1)} do {
		nl += { this[i] };
	}
	this = nl;
	return this;
}

Vector::shift(ref this) => {
	var nl = {};
	i in {1 until len this} do {
		nl += { this[i] };
	}
	this = nl;
	return this;
}

Vector::front(ref this) => {
	return this[0];
}

Vector::back(ref this) => {
	return this[len this - 1];
}

Vector::isEmpty(ref this) => {
	return (len this == 0);
}

Vector::contains(ref this, ref value) => {
	i in this do {
		i == value then {
			return true;
		}
	}
	return false;
}

Vector::push(ref this, ref value) => {
	this += { value };
	return this;
}

Vector::join(ref this, del) => {
	del == null then {
		del = "";
	}
	var string = "";
	e in this do {
		string += str e;
	}
	return string;
}

Vector::remove(ref this, final index) => {
	var nv = {};
	i in {0 until len this} do {
		i != index then {
			nv += { this[i] };
		}
	}
	this = nv;
	return this;
}

Vector::distArray(ref this, final vector, costDel, costIns, costRep) => {
	costDel == null then {
		costDel = 1;
	}
	costIns == null then {
		costIns = 1;
	}
	costRep == null then {
		costRep = 1;
	}

	var m = len this;
	var n = len vector;
	var array = {0 until (m + 1)};
	i in array do {
		i = {0 until (n + 1)};
		j in i do {
			j = 0;
		}
	}
	i in {1 until (m + 1)} do {
		array[i][0] = i;
	}
	i in {1 until (n + 1)} do {
		array[0][i] = i;
	}

	i in {1 until (m + 1)} do {
		j in {1 until (n + 1)} do {
			array[i][j] = Math.min({
				array[i - 1][j] + costDel,	# DELETION
				array[i][j - 1] + costIns,	# INSERTION
				array[i - 1][j - 1] + (this[i - 1] != vector[j - 1]) * costRep	# REPLACEMENT
			});
		}
	}

	return array;
}

Vector::dist(ref this, ref vector, final costDel, final costIns, final costRep) => {
	return this.distArray(vector, costDel, costIns, costRep)[len this][len vector];
}

Vector::steps(ref this, ref vector, final costDel, final costIns, final costRep) => {
	var D = this.distArray(vector, costDel, costIns, costRep);
	var i = len this;
	var j = len vector;
	var steps = {};
	true do {
		i > 0 then {
			j > 0 then {
				D[i - 1][j] <= D[i][j - 1] then {
					D[i - 1][j] < D[i - 1][j - 1] then {
						steps += {{"DEL", i - 1, this[i - 1]}};
					} else {
						D[i][j] != D[i - 1][j - 1] then {
							steps += {{"SUB", i - 1, this[i - 1], vector[j - 1]}};
						}
						j -= 1;
					}
					i -= 1;
				} else {
					D[i][j - 1] <= D[i - 1][j - 1] then {
						steps += {{"INS", i - 1, vector[j - 1]}};
					} else {
						D[i][j] != D[i - 1][j - 1] then {
							steps += {{"SUB", i - 1, this[i - 1], vector[j - 1]}};
						}
						i -= 1;
					}
					j -= 1;
				}
			} else {
				steps += {{"DEL", i - 1, this[i - 1]}};
				i -= 1;
			}
		} else j > 0 then {
			steps += {{"DEL", i - 1, this[i - 1]}};
			j -= 1;
		} else {
			return steps.reverse();
		}
	}
}

Vector::reverse(final this) => {
	var nv = {};
	i in {0 until len this} do {
		nv += { this[len this - i - 1] };
	}
	return nv;
}

Vector::nGram(final this, final n) => {
	var nv = {};
	i in {0 until (len this - n + 1)} do {
		var gram = {};
		j in {0 until n} do {
			gram += {this[i + j]};
		}
		nv += {gram};
	}
	return nv;
}

Vector::sort(final this, comp) => {
	comp == null then {
		comp = (a, b) => { return a < b; };
	} else type comp != "Function" then {
		throw "Parameter <comp> of Vector::sort() must be of type Function";
	}
	Vector::merge_sort(final this) => {
		len this <= 1 then {
			return this;
		}
		var a = {};
		var b = {};
		i in {1 until len this} do {
			comp(this[i], this[0]) then {
				a += { this[i] };
			} else {
				b += { this[i] };
			}
		}
		return a.merge_sort() + { this[0] } + b.merge_sort();
	}
	return this.merge_sort();
}

Vector::map(final this, final function) => {
	var nl = {};
	e in this do {
		nl += { function(e) };
	}
	return nl;
}

Vector::filter(final this, final function) => {
	var nl = {};
	e in this do {
		function(e) then {
			nl += { e };
		}
	}
	return nl;
}

Vector::foldRight(final this, final function) => {
	len this == 1 then {
		return this[0];
	}
	var nl = this;
	return function(this[0], nl.shift().foldRight(function));
}

Vector::foldLeft(final this, final function) => {
	len this == 1 then {
		return this[0];
	}
	var nl = this;
	return function(nl.pop().foldLeft(function), this[len this - 1]);
}