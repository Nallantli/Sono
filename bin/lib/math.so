# Benjamin Park
# 08-07-2020

Number::abs(ref this) => {
	this < 0 then {
		return -this ;
	} else {
		return +this;
	}
}

Number::floor(ref this) => {
	var d = ((this * 10) % 10) / 10;
	this >= 0 then {
		return this - d;
	} else {
		return this - d - 1;
	}
}

Number::ceil(ref this) => {
	var d = ((this * 10) % 10) / 10;
	this > 0 then {
		d > 0 then {
			return this - d + 1;
		} else {
			return +this;
		}
	} else {
		d < 0 then {
			return this - d;
		} else {
			return +this;
		}
	}
}

Number::round(ref this) => {
	var f = this.floor();
	var c = this.ceil();
	var df = (this - f).abs();
	var dc = (this - c).abs();
	df < dc then {
		return f;
	} else {
		return c;
	}
}

Number::format(ref this, final d) => {
	var s = vec str this;
	var ns = "";
	var i = 0;
	var mode = true;
	c in s do {
		mode then {
			ns += c;
			c == "." then {
				mode = false;
			}
		} else {
			i < d then {
				ns += c;
			} else {
				break;
			}
			i += 1;
		}
	}
	i == 0 then {
		ns += ".";
	}
	i < d do {
		ns += "0";
		i += 1;
	}
	return ns;
}

static Math class {
	min(ref vector) => {
		var n = vector[0];
		i in {1 until len vector} do {
			vector[i] < n then {
				n = vector[i];
			}
		}
		return n;
	}

	minIndex(ref vector) => {
		var n = vector[0];
		var index = 0;
		i in {1 until len vector} do {
			vector[i] < n then {
				n = vector[i];
				index = i;
			}
		}
		return index;
	}

	add(ref a, ref b) => {
		return a + b;
	}

	sub(ref a, ref b) => {
		return a - b;
	}

	mul(ref a, ref b) => {
		return a * b;
	}

	div(ref a, ref b) => {
		return a / b;
	}

	mod(ref a, ref b) => {
		return a % b;
	}

	pow(ref a, ref b) => {
		return a ** b;
	}
}